import{_ as t,c as a,o,ag as s}from"./chunks/framework.BpVvFBTM.js";const u=JSON.parse('{"title":"Events","description":"","frontmatter":{},"headers":[],"relativePath":"concepts/events.md","filePath":"concepts/events.md"}'),l={name:"concepts/events.md"};function n(r,e,i,d,c,h){return o(),a("div",null,[...e[0]||(e[0]=[s('<h1 id="events" tabindex="-1">Events <a class="header-anchor" href="#events" aria-label="Permalink to &quot;Events&quot;">​</a></h1><p>DH-UI uses events to coordinate changes between blocks that show resources (like HP, Stress, Armor, Hope) and tools that modify them (like rest and damage).</p><p>Most users only need to understand the <strong>concepts</strong> on this page. The low-level DOM event API for custom integrations is documented separately on the <a href="/DH-UI/events/templates-events.html">Events (API)</a> page.</p><h2 id="file-scope" tabindex="-1">File scope <a class="header-anchor" href="#file-scope" aria-label="Permalink to &quot;File scope&quot;">​</a></h2><p>Events in DH-UI are <strong>file-scoped</strong>:</p><ul><li>Rest and damage operate only on trackers in the <strong>same note preview</strong>.</li><li>Full Heal and Reset All only clear trackers that exist in the current note.</li><li>You can have multiple character sheets in different notes without them affecting each other.</li></ul><p>This is why most defaults include the current note’s path in their state keys (e.g. <code>din_health::Characters/Marlowe</code>).</p><h2 id="built-in-event-flows" tabindex="-1">Built-in event flows <a class="header-anchor" href="#built-in-event-flows" aria-label="Permalink to &quot;Built-in event flows&quot;">​</a></h2><p>DH-UI wires several blocks together so that a single action can update multiple components.</p><h3 id="rest-→-vitals" tabindex="-1">Rest → Vitals <a class="header-anchor" href="#rest-→-vitals" aria-label="Permalink to &quot;Rest → Vitals&quot;">​</a></h3><p>When you use the <code>rest</code> block:</p><ul><li>It finds the HP / Stress / Armor / Hope trackers in the current note.</li><li>It uses their configured <code>hp_key</code>, <code>stress_key</code>, <code>armor_key</code>, and <code>hope_key</code>.</li><li>Short Rest / Long Rest / Full Heal / Reset All update the stored values for those keys.</li><li>Trackers listening to those keys redraw automatically.</li></ul><p>Conceptually:</p><ol><li><strong>Trackers</strong> (from <code>vitals</code> or individual <code>hp</code> / <code>stress</code> / <code>armor</code> / <code>hope</code> blocks) expose state keys.</li><li><strong>Rest</strong> reads those keys and applies healing / resets.</li><li>The state store is updated; trackers refresh from the new values.</li></ol><h3 id="damage-→-vitals" tabindex="-1">Damage → Vitals <a class="header-anchor" href="#damage-→-vitals" aria-label="Permalink to &quot;Damage → Vitals&quot;">​</a></h3><p>Similarly, the <code>damage</code> block:</p><ul><li>Calculates the damage tier based on your thresholds and level.</li><li>Applies tiered damage to HP using its <code>hp_key</code>.</li><li>Optionally spends Armor slots using <code>armor_key</code>.</li><li>Trackers listening to those keys redraw to show the new HP / Armor state.</li></ul><p>To keep things consistent, you normally want:</p><ul><li>The <code>vitals</code> block and the <code>damage</code> block to use the <strong>same</strong> <code>hp_key</code> / <code>armor_key</code>.</li><li>The <code>rest</code> block to auto-detect or explicitly use those same keys.</li></ul><h2 id="state-updates-and-redraws" tabindex="-1">State updates and redraws <a class="header-anchor" href="#state-updates-and-redraws" aria-label="Permalink to &quot;State updates and redraws&quot;">​</a></h2><p>Behind the scenes, DH-UI:</p><ol><li>Writes new values into the state store (using keys like <code>tracker:din_health::Character/Marlowe</code>).</li><li>Emits internal events so all tracker components bound to that key can update.</li><li>React-based tracker views pick up the change and repaint.</li></ol><p>You don&#39;t need to call any of these events yourself when using the built-in blocks; they are handled automatically when you click the UI.</p><h2 id="advanced-integrations" tabindex="-1">Advanced integrations <a class="header-anchor" href="#advanced-integrations" aria-label="Permalink to &quot;Advanced integrations&quot;">​</a></h2><p>If you are writing custom JS snippets or extending DH-UI in code, you can hook into the low-level event API:</p><ul><li><code>dh:tracker:changed</code> – fired when a tracker row changes.</li><li><code>dh:kv:changed</code> – fired when a key in the KV/state store changes.</li><li><code>dh:rest:short</code> / <code>dh:rest:long</code> – fired when rest actions are applied.</li></ul><p>See the <strong>Events (API)</strong> page for full details on these DOM events and helper functions.</p><p>For most vault setups you can ignore the internals and rely on:</p><ul><li><code>vitals</code> + <code>rest</code> + <code>damage</code> blocks,</li><li>Note-scoped state keys, and</li><li>The automatic redraw behavior described above.</li></ul>',29)])])}const m=t(l,[["render",n]]);export{u as __pageData,m as default};
