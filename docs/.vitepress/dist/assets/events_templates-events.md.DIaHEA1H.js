import{_ as t,c as s,o as r,ag as n,j as e,a as o}from"./chunks/framework.BpVvFBTM.js";const f=JSON.parse('{"title":"Templates & Events","description":"","frontmatter":{},"headers":[],"relativePath":"events/templates-events.md","filePath":"events/templates-events.md"}'),i={name:"events/templates-events.md"};function l(p,a,c,d,h,m){return r(),s("div",null,[...a[0]||(a[0]=[n('<h1 id="templates-events" tabindex="-1">Templates &amp; Events <a class="header-anchor" href="#templates-events" aria-label="Permalink to &quot;Templates &amp; Events&quot;">​</a></h1><p>Anywhere you can provide a string in block YAML, you can usually use templates like <span><code>{{ frontmatter.hp }}</code></span>.<br> Templates are evaluated against a shared template context and are supported in blocks such as badges, features, vitals, trackers, consumables, experiences, damage, and more.</p><p>If a template expression fails, it resolves to an empty string instead of throwing. When a number is expected and the result isn’t numeric, it is treated as 0.</p><h2 id="template-paths" tabindex="-1">Template paths <a class="header-anchor" href="#template-paths" aria-label="Permalink to &quot;Template paths&quot;">​</a></h2><p>These are the main paths you can use inside <span><code>{{ ... }}</code></span>:</p><p>• frontmatter.* – raw note frontmatter. ◦ Examples: ▪ <span><code>{{ frontmatter.level }}</code></span> ▪ <span><code>{{ frontmatter.hp_max }}</code></span> • abilities.* – totals derived from the nearest ```traits block in the same section. ◦ The plugin parses that block and computes final scores, then exposes them in a case‑insensitive map. ◦ Examples: ▪ <span><code>{{ abilities.agility }}</code></span> ▪ <span><code>{{ abilities.knowledge }}</code></span> • skills.* – numeric skills/moves from skills in frontmatter. ◦ Supports either: ▪ A map:<br> skills: { attack: 2, sneak: 3 } • Or a list:<br> skills: [ { name: &quot;attack&quot;, value: 2 }, { name: &quot;sneak&quot;, value: 3 } ] • Examples: ◦ <span><code>{{ skills.attack }}</code></span> ◦ <span><code>{{ skills.sneak }}</code></span> • character.* – derived summary from frontmatter. ◦ Fields include: ▪ character.name – typically from name or title. ▪ character.level – from level or tier (whichever is present). ▪ character.tier – from tier or level. ▪ character.hp, character.stress, character.armor, character.hope – from corresponding frontmatter (hp/health/din_health, etc.). ◦ Examples: ▪ <span><code>{{ character.level }}</code></span> ▪ <span><code>{{ character.hp }}</code></span></p><p>You can also use bare numbers and these paths as arguments to helper functions (see next section).</p><h2 id="helper-functions" tabindex="-1">Helper functions <a class="header-anchor" href="#helper-functions" aria-label="Permalink to &quot;Helper functions&quot;">​</a></h2><p>The template engine provides a few simple helpers for math and formatting. They work like:</p><p>• <span><code>{{ add 2 frontmatter.level }}</code></span><br> • <span><code>{{ subtract frontmatter.hp 2 }}</code></span><br> • <span><code>{{ multiply 2 frontmatter.level }}</code></span><br> • <span><code>{{ divide frontmatter.hp 2 }}</code></span><br> • <span><code>{{ floor divide frontmatter.hp 2 }}</code></span></p><p>Supported helpers:</p><p>• add a b c ... – sum of all arguments.<br> • subtract a b c ... – a - b - c - ....<br> • multiply a b c ... – product of all arguments.<br> • divide a b c ... – a / b / c / ... (division by zero yields NaN → treated as 0 when a number is needed).<br> • floor x – Math.floor(x).<br> • ceil x – Math.ceil(x).<br> • round x – Math.round(x).<br> • modifier x – pass‑through numeric value (mainly for readability, e.g. <span><code>{{ modifier abilities.agility }}</code></span>).</p><p>Arguments can be:</p><p>• Plain numbers: 2, 3.5, -1.<br> • Template paths: frontmatter.level, abilities.agility, skills.attack, character.hp.</p><p>If a token cannot be parsed as a number, it is treated as 0 for numeric helpers.</p><h2 id="events" tabindex="-1">Events <a class="header-anchor" href="#events" aria-label="Permalink to &quot;Events&quot;">​</a></h2><p>The plugin fires custom DOM events so different blocks and integrations can react to changes.</p><p>Core events:</p>',18),e("p",{"filePath,":"","hpKey,":"","stressKey,":"","armorKey,":"",hopeKey:""},[o("• dh:tracker:changed – emitted when a tracker row (HP/Stress/Armor/Hope/uses/etc.) changes. ◦ Detail: { key, filled } ▪ key: the tracker’s state key (e.g. din_health). ▪ filled: current number of filled boxes. • dh:kv:changed – emitted when a key in the KV/state store changes. ◦ Detail: { key, val } ▪ key: the KV key that changed. ▪ val: the new value. • dh:rest:short – emitted when a Short Rest is applied. • dh:rest:long – emitted when a Long Rest is applied. ◦ Detail for both rest events:"),e("br")],-1),e("p",null,"These are primarily for advanced users writing custom JS snippets or other plugins.",-1),e("p",null,"If you’re extending DH‑UI in code, prefer using the helpers from src/utils/events.ts:",-1),e("p",null,"• Emitters: ◦ emitTrackerChanged({ key, filled }) ◦ emitKvChanged({ key, val }) ◦ emitRestShort({ filePath, hpKey, stressKey, armorKey, hopeKey }) ◦ emitRestLong({ filePath, hpKey, stressKey, armorKey, hopeKey }) • Listeners (return an unsubscribe function): ◦ onTrackerChanged(handler) ◦ onKvChanged(handler) ◦ onRestShort(handler) ◦ onRestLong(handler)",-1),e("p",null,"Using these helpers keeps event names and payload shapes consistent across the plugin.",-1)])])}const b=t(i,[["render",l]]);export{f as __pageData,b as default};
